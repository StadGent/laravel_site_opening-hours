<?php

namespace App\Console\Commands;

use App\Events\OpeninghoursUpdated;
use App\Models\Calendar;
use App\Models\Channel;
use App\Models\Event;
use App\Models\Openinghours;
use Carbon\Carbon;
use Illuminate\Console\Command;

class FetchRecreatex extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'openinghours:fetch-recreatex';

    /**
     * The SHOP ID for the RECREATEX service
     *
     * @var string
     */
    protected $shopId;

    /**
     * The Recreatex SOAP URI
     *
     * @var string
     */
    protected $recreatexUri;

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Fetch RECREATEX openinghours data';

    /**
     * The start of the calendar
     * @var string
     */
    const CALENDAR_START = '2017';

    /**
     * The end of the calendar
     * @var string
     */
    const CALENDAR_END = '2020';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();

        $this->shopId = env('SHOP_ID');
        $this->recreatexUri = env('RECREATEX_URI');

        if (empty($this->shopId)) {
            \Log::error("No shop ID was found, we can't fetch openinghours from the RECREATEX webservice without it.
                You can configure a shop ID in the .env file.");
        }

        if (empty($this->recreatexUri)) {
            \Log::error("No recreatexUri was found, we can't fetch openinghours from the RECREATEX webservice without it.
                You can configure a recreatexUri in the .env file.");
        }
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        $recreatexServices = app('ServicesRepository')->where('source', 'recreatex')->get();

        foreach ($recreatexServices as $recreatexService) {
            if (! empty($recreatexService->identifier)) {
                for ($year = self::CALENDAR_START; $year <= self::CALENDAR_END; $year++) {
                    $openinghoursList = $this->getOpeninghours($recreatexService->identifier, $year);

                    // If openinghours were found, create a channel for the service
                    // and add the events passed in $openinghoursList to an openinghours object
                    // of the channel, the default channel is called "Infrastructuur-YYYY"
                    $channelName = 'Infrastructuur-' . $year;

                    if (! empty($openinghoursList)) {
                        $openinghoursList = $this->transformOpeninghours($openinghoursList, $year);
                    }

                    if (! empty($openinghoursList) && ! $this->serviceHasAutogeneratedChannel($recreatexService, $channelName)) {
                        $channel = new Channel();
                        $channel->label = $channelName;

                        // Link the channel to the service
                        $recreatexService->channels()->save($channel);

                        $openinghours = new Openinghours();
                        $openinghours->active = true;
                        $openinghours->start_date = self::CALENDAR_START . '-01-01';
                        $openinghours->end_date = self::CALENDAR_START . '-12-31';
                        $openinghours->label = 'GeÃ¯mporteerde kalender ' . $openinghours->start_date . ' - ' . $openinghours->end_date;

                        // Link the openinghours to the channel
                        $channel->openinghours()->save($openinghours);

                        $calendar = new Calendar();
                        $calendar->priority = 0;
                        $calendar->closinghours = 0;
                        $calendar->label = 'Openingsuren';

                        // Link the calendar to the openinghours
                        $openinghours->calendars()->save($calendar);

                        $sequenceNumber = 1;

                        foreach ($openinghoursList as $openinghoursEvent) {
                            // Transform the days
                            $weekDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

                            $weekDayRrule = [];

                            foreach ($openinghoursEvent['days'] as $index => $day) {
                                $weekDayRrule[] = $weekDays[$day];
                            }

                            $event = new Event();
                            $event->rrule = 'BYDAY=' . implode(',', $weekDayRrule) . ';FREQ=WEEKLY';
                            $event->start_date = $openinghoursEvent['start']->toIso8601String();
                            $event->end_date = $openinghoursEvent['end']->toIso8601String();
                            $event->label = $sequenceNumber;
                            $event->until = $openinghoursEvent['until']->startOfDay()->format('Y-m-d');

                            // Link event to the calendar
                            $calendar->events()->save($event);

                            $sequenceNumber++;
                        }

                        $this->info('Imported calendar for year ' . $year . ' for service ' . $recreatexService->label . '(' . $recreatexService->identifier . ')');

                        event(new OpeninghoursUpdated($openinghours->id));
                    } else {
                        if (empty($openinghoursList)) {
                            $this->info('The service ' . $recreatexService->identifier . " has no events for year $year.");
                        } else {
                            $this->info('The service ' . $recreatexService->identifier . " already has a channel $channelName, therefore we did not import any openinghours for this specific service.");
                        }
                    }
                }
            }
        }
    }

    /**
     * Transform a list of openinghours to a shorter list that
     * holds RRULEs on a weekly frequency as much as possible, starting
     * from a list of daily (!!) events over 1 year.
     *
     * @param  array $openinghoursList
     * @return array
     */
    private function transformOpeninghours($openinghoursList)
    {
        $transformedList = [];

        // Keep track of weekly recurring dates
        $weekBuffer = [];

        foreach ($openinghoursList as $openinghoursEvent) {
            $timespans = [];

            $until = '';

            if (! empty($openinghoursEvent['From1']) && ! empty($openinghoursEvent['To1'])) {
                $from = Carbon::createFromFormat('Y-m-d\TH:i:s', $openinghoursEvent['From1']);
                $to = Carbon::createFromFormat('Y-m-d\TH:i:s', $openinghoursEvent['To1']);

                $key = $from->format('H:i') . '-' . $to->format('H:i');

                $timespans[$key] = $from->dayOfWeek;
                $parsedWeek = $from->weekOfYear;
                $until = $to;
            }

            if (! empty($openinghoursEvent['From2']) && ! empty($openinghoursEvent['To2'])) {
                $from = Carbon::createFromFormat('Y-m-d\TH:i:s', $openinghoursEvent['From2']);
                $to = Carbon::createFromFormat('Y-m-d\TH:i:s', $openinghoursEvent['To2']);

                $key = $from->format('H:i') . '-' . $to->format('H:i');

                $timespans[$key] = $from->dayOfWeek;
                $parsedWeek = $from->weekOfYear;
                $until = $to;
            }

            // Add the timespans to the week schedule
            if (! empty($timespans)) {
                foreach ($timespans as $timespan => $day) {
                    if (empty($weekBuffer[$parsedWeek]['schedules'])) {
                        $weekBuffer[$parsedWeek] = [];
                        $weekBuffer[$parsedWeek]['schedules'] = [];
                    }

                    if (empty($weekBuffer[$parsedWeek]['schedules'][$timespan])) {
                        $weekBuffer[$parsedWeek]['schedules'][$timespan] = ['days' => [$day], 'start' => $from, 'end' => $to, 'until' => $to];
                    } else {
                        $weekBuffer[$parsedWeek]['schedules'][$timespan]['days'][] = $day;
                        asort($weekBuffer[$parsedWeek]['schedules'][$timespan]['days']);
                        $weekBuffer[$parsedWeek]['schedules'][$timespan]['until'] = $to;
                    }

                    $weekBuffer[$parsedWeek]['until'] = $until;
                }
            }
        }

        // All year closed
        if (empty($weekBuffer)) {
           return [];
        }

        $firstWeek = key($weekBuffer);

        $recurringBuffer = $weekBuffer[$firstWeek]['schedules'];
        unset($weekBuffer[$firstWeek]);

        foreach ($weekBuffer as $weekNumber => $weekConfig) {
            $schedule = $weekConfig['schedules'];
            $until = $weekConfig['until'];

            $newBuffer = [];

            foreach ($schedule as $timespan => $timespanConfig) {
                if (array_key_exists($timespan, $recurringBuffer) && $timespanConfig['days'] == $recurringBuffer[$timespan]['days']) {
                    $recurringBuffer[$timespan]['until'] = $until;
                } else {
                    $newBuffer[$timespan] = $timespanConfig;
                }
            }

            // Filter out the events that did not receive an updated until date
            $tmpBuffer = [];

            foreach ($recurringBuffer as $timespan => $config) {
                if ($config['until']->toDateString() != $until->toDateString()) {
                    $transformedList[] = $config;
                } else {
                    $tmpBuffer[$timespan] = $config;
                }
            }

            $recurringBuffer = $tmpBuffer;

            // Merge the recurring rules with the new timespans
            // if timespans overlap, this means that the old rule should be put
            // into the final list of events as well
            foreach ($newBuffer as $timespan => $config) {
                if (array_key_exists($timespan, $recurringBuffer)) {
                    $transformedList[] = $config;

                }

                $recurringBuffer[$timespan] = $config;
            }
        }

        foreach ($recurringBuffer as $timespan => $config) {
            $transformedList[] = $config;
        }

        return $transformedList;
    }

    /**
     * Determine if the service has a channel called "Infrastructuur"
     *
     * @param  Eloquent $service
     * @param  string   $channelName
     * @return boolean
     */
    private function serviceHasAutogeneratedChannel($service, $channelName)
    {
        $channels = $service->channels;

        if (empty($channels)) {
            return false;
        }

        return $channels->contains(function ($value) use ($channelName) {
            return $value->label == $channelName;
        });
    }

    /**
     * Fetch the recreatex openinghours for a certain infrastructure
     *
     * @param  string $recreatexId
     * @param  int    $year
     * @return array
     */
    private function getOpeninghours($recreatexId, $year)
    {
        $soapBody = $this->makeSoapBody($recreatexId, $year);

        $headers = [
            'Content-type: text/xml;charset="utf-8"',
            'Accept: text/xml',
            'Cache-Control: no-cache',
            'Pragma: no-cache',
            'SOAPAction:  http://www.recreatex.be/webshop/v3.8/IWebShop/FindInfrastructureOpenings',
            'Content-length: ' . strlen($soapBody),
        ];

        $ch = curl_init();
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
        curl_setopt($ch, CURLOPT_URL, $this->recreatexUri);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_ANY);
        curl_setopt($ch, CURLOPT_TIMEOUT, 20);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $soapBody);
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);

        $response = curl_exec($ch);

        curl_close($ch);

        // Remove the SOAP envelop
        $response = str_replace('<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body>', '', $response);
        $response = str_replace('</s:Body></s:Envelope>', '', $response);

        $xml = simplexml_load_string($response);
        $json = json_encode($xml);
        $fullJson = json_decode($json, true);

        // Parse the InfrastructureOpeningHours from the body
        return array_get($fullJson, 'InfrastructureOpeningHours.InfrastructureOpeningHours.OpenHours.OpeningHour', []);
    }

    private function makeSoapBody($recreatexId, $year)
    {
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:v3="http://www.recreatex.be/webshop/v3.8/">
                   <soapenv:Header/>
                   <soapenv:Body>
                      <v3:Context>
                         <v3:ShopId>' . $this->shopId . '</v3:ShopId>
                      </v3:Context>
                      <v3:InfrastructureOpeningsSearchCriteria>
                         <v3:InfrastructureId>' . $recreatexId . '</v3:InfrastructureId>
                         <v3:From>' . $year . '-01-01T00:00:00.8115784+02:00</v3:From>
                         <v3:Until>' . ++$year . '-01-01T00:00:00.8115784+02:00</v3:Until>
                      </v3:InfrastructureOpeningsSearchCriteria>
                   </soapenv:Body>
                </soapenv:Envelope>';
    }
}
